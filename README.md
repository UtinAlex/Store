Сборка проекта:
docker-compose up --build
(Записи с id 1 и 2 уже будут в БД),
миграции при первой сборке не выполняются,
запустите docker-compose up --build второй раз,
миграции выполнятся

Api работает на localhost:8005
Пример в Postman  http://localhost:8005/api/games
Ответ:
[
    {
        "id": 1,
        "title": "Шахматы",
        "studio": "Chess Mentor",
        "genre": "Настольная логическая"
    },
    {
        "id": 2,
        "title": "DOOM",
        "studio": "id Software",
        "genre": "Шутер"
    }
]


Все роуты:
docker exec -it store-api php artisan route:list



Добрый день
1. GameViewModel.index() Оптимизировать кол-во запросов при получении данных
2. GameViewModel.store() Предусмотреть существование записей в Title, Studio, Genre
3. Почему для заполнения массива используется += вместо обычного присваивания по ключу?
4. GameViewModel.destroy() При удалении игры удалятся и связанные данные. А что если у других игр есть связи с ними?
5. GameViewModel. Вью модельки предназначены для сбора информации для отображения. А у вас в них идет еще и изменение данных. Необходимо убрать из GameViewModel логику изменения данных.


По первому пункту добавил пагинацию GameViewModel.index():
 $games = Game::query()->paginate(1); и array_push($valuesArrIdGames, $games);  так же предаю информацию для пагинации .

По второму и пятому пункту GameViewModel.store(): 
Создал логику проверки существования  Title, Studio, Genre и вынес логику создания новой игры в модель Game.

По третьему пункту последовательно добавляем элементы += в массив, если использовать простое присвоение = ,в массиве будет только один последний элемент.
 
По четвёртому пункту GameViewModel.destroy():
Согласен нарушение целостности БД, каскадное удаление не требуется. Удалил.

По пятому пункту вынес логику изменения игры в модель Game. 
